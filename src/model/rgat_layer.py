"""Heterograph NN modules"""
import torch as th
import torch.nn as nn
import torch.nn.functional as F
from torch.nn import init
import logging

logger = logging.getLogger(__name__)
__all__ = ['HeteroGraphAttentionConv']

class HeteroGraphAttentionConv(nn.Module):
    r"""A generic module for computing convolution on heterogeneous graphs.

    The heterograph convolution applies sub-modules on their associating
    relation graphs, which reads the features from source nodes and writes the
    updated ones to destination nodes. If multiple relations have the same
    destination node types, their results are aggregated by the specified method.

    If the relation graph has no edge, the corresponding module will not be called.


    Parameters
    ----------
    mods : dict[str, nn.Module]
        Modules associated with every edge types. The forward function of each
        module must have a `DGLHeteroGraph` object as the first argument, and
        its second argument is either a tensor object representing the node
        features or a pair of tensor object representing the source and destination
        node features.
    aggregate : str, callable, optional
        Method for aggregating node features generated by different relations.
        Allowed string values are 'sum', 'max', 'min', 'mean', 'stack'.
        The 'stack' aggregation is performed along the second dimension, whose order
        is deterministic.
        User can also customize the aggregator by providing a callable instance.
        For example, aggregation by summation is equivalent to the follows:

        .. code::

            def my_agg_func(tensors, dsttype):
                # tensors: is a list of tensors to aggregate
                # dsttype: string name of the destination node type for which the
                #          aggregation is performed
                stacked = torch.stack(tensors, dim=0)
                return torch.sum(stacked, dim=0)

    Attributes
    ----------
    mods : dict[str, nn.Module]
        Modules associated with every edge types.
    """
    def __init__(self, mods, att_in_feats, att_out_feats, aggregate='sum', alpha=0.5):
        super(HeteroGraphAttentionConv, self).__init__()
        self.mods = nn.ModuleDict(mods)
        # Do not break if graph has 0-in-degree nodes.
        # Because there is no general rule to add self-loop for heterograph.
        for _, v in self.mods.items():
            set_allow_zero_in_degree_fn = getattr(v, 'set_allow_zero_in_degree', None)
            if callable(set_allow_zero_in_degree_fn):
                set_allow_zero_in_degree_fn(True)

        # attention weight
        self.att_in_feats =att_in_feats
        self.att_out_feats = att_out_feats
        # self.att_weight = nn.Parameter(th.Tensor(self.att_in_feats, self.att_out_feats))
        self.att_cat_weight = nn.Parameter(th.Tensor(self.att_out_feats*2, 1))
        self.att_aggregation = aggregate
        self.alpha = alpha
        self.reset_parameters()

        if isinstance(aggregate, str):
            if self.is_trainable(aggregate):
                self.agg_fn = self.get_trainable_aggregate_fn(aggregate)
            else:
                self.agg_fn = get_aggregate_fn(aggregate)
        else:
            self.agg_fn = aggregate

    def reset_parameters(self):
        r"""

        Description
        -----------
        Reinitialize learnable parameters.

        Note
        ----
        The model parameters are initialized as in the
        `original implementation <https://github.com/tkipf/gcn/blob/master/gcn/layers.py>`__
        where the weight :math:`W^{(l)}` is initialized using Glorot uniform initialization
        and the bias is initialized to be zero.

        """
        if self.att_cat_weight is not None:
            init.xavier_uniform_(self.att_cat_weight)
        # if self.bias is not None:
        #     init.zeros_(self.bias)

    def forward(self, g, inputs, mod_args=None, mod_kwargs=None):
        """Forward computation

        Invoke the forward function with each module and aggregate their results.

        Parameters
        ----------
        g : DGLHeteroGraph
            Graph data.
        inputs : dict[str, Tensor] or pair of dict[str, Tensor]
            Input node features.
        mod_args : dict[str, tuple[any]], optional
            Extra positional arguments for the sub-modules.
        mod_kwargs : dict[str, dict[str, any]], optional
            Extra key-word arguments for the sub-modules.

        Returns
        -------
        dict[str, Tensor]
            Output representations for every types of nodes.
        """
        if mod_args is None:
            mod_args = {}
        if mod_kwargs is None:
            mod_kwargs = {}
        outputs = {nty : {} for nty in g.dsttypes}
        if isinstance(inputs, tuple) or g.is_block:
            if isinstance(inputs, tuple):
                src_inputs, dst_inputs = inputs
            else:
                src_inputs = inputs
                dst_inputs = {k: v[:g.number_of_dst_nodes(k)] for k, v in inputs.items()}

            for stype, etype, dtype in g.canonical_etypes:
                rel_graph = g[stype, etype, dtype]
                if rel_graph.number_of_edges() == 0:
                    continue
                if stype not in src_inputs or dtype not in dst_inputs:
                    continue
                dstdata = self.mods[etype](
                    rel_graph,
                    (src_inputs[stype], dst_inputs[dtype]),
                    *mod_args.get(etype, ()),
                    **mod_kwargs.get(etype, {}))
                outputs[dtype][etype] = dstdata
        else:
            for stype, etype, dtype in g.canonical_etypes:
                rel_graph = g[stype, etype, dtype]
                if rel_graph.number_of_edges() == 0:
                    continue
                if stype not in inputs:
                    continue
                dstdata = self.mods[etype](
                    rel_graph,
                    inputs[stype],
                    *mod_args.get(etype, ()),
                    **mod_kwargs.get(etype, {}))
                outputs[dtype][etype] = dstdata
        rsts = {}
        for nty, adict in outputs.items():
            if len(adict) != 0:
                if self.is_trainable(self.att_aggregation):
                    alist = []
                    # og_dst_feature = inputs[nty]
                    new_self_feature = None

                    for k in adict.keys():
                        if k =="self_connection":
                            new_self_feature = adict[k]
                            continue
                        alist.append(adict[k])

                    rsts[nty] = self.agg_fn(alist, new_self_feature)
                else:
                    alist = [adict[k] for k in adict.keys()]
                    rsts[nty] = self.agg_fn(alist, nty)
        return rsts

    def is_trainable(self, aggregation):
        trainable_list = ["attention"]
        if aggregation in trainable_list:
            return True
        return False

    def get_trainable_aggregate_fn(self, aggregate):
        if aggregate=="attention":
            def multi_relational_attention_aggregation(new_src_feature_list, new_self_feature):
                stacked = th.stack(new_src_feature_list, dim=1)
                catted = th.cat((stacked, new_self_feature.expand_as(stacked.transpose(0,1)).transpose(0,1)), dim=2)

                e =  th.matmul(catted, self.att_cat_weight)
                score = F.softmax(F.leaky_relu(e), dim=1)
                agged_dst = th.sum(score * stacked, dim=1)
                return (1-self.alpha)*agged_dst + self.alpha*new_self_feature if self.alpha*new_self_feature is not None else agged_dst
            return multi_relational_attention_aggregation


def get_aggregate_fn(agg):
    """Internal function to get the aggregation function for node data
    generated from different relations.

    Parameters
    ----------
    agg : str
        Method for aggregating node features generated by different relations.
        Allowed values are 'sum', 'max', 'min', 'mean', 'stack'.

    Returns
    -------
    callable
        Aggregator function that takes a list of tensors to aggregate
        and returns one aggregated tensor.
    """
    if agg == 'sum':
        fn = th.sum
    elif agg == 'max':
        fn = lambda inputs, dim: th.max(inputs, dim=dim)[0]
    elif agg == 'min':
        fn = lambda inputs, dim: th.min(inputs, dim=dim)[0]
    elif agg == 'mean':
        fn = th.mean
    elif agg == 'stack':
        fn = None  # will not be called
    else:
        raise DGLError('Invalid cross type aggregator. Must be one of '
                       '"sum", "max", "min", "mean" or "stack". But got "%s"' % agg)
    if agg == 'stack':
        def stack_agg(inputs, dsttype):  # pylint: disable=unused-argument
            if len(inputs) == 0:
                return None
            return th.stack(inputs, dim=1)
        return stack_agg
    else:
        def aggfn(inputs, dsttype):  # pylint: disable=unused-argument
            if len(inputs) == 0:
                return None
            stacked = th.stack(inputs, dim=0)
            return fn(stacked, dim=0)
        return aggfn
